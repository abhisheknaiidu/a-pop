{"ast":null,"code":"var parser = require('graphql/language/parser');\n\nvar parse = parser.parse; // Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\n\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n} // A map docString -> graphql document\n\n\nvar docCache = {}; // A map fragmentName -> [normalized source]\n\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n} // For testing.\n\n\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n} // Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\n\n\nvar printFragmentWarnings = true;\n\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc); // We know something about this fragment\n\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  } // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n\n\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  } // https://github.com/apollographql/graphql-tag/issues/40\n\n\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\n\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, {\n    experimentalFragmentVariables: experimentalFragmentVariables\n  });\n\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  } // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n\n\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n} // XXX This should eventually disallow arbitrary string interpolation, like Relay does\n\n\nfunction gql()\n/* arguments */\n{\n  var args = Array.prototype.slice.call(arguments);\n  var literals = args[0]; // We always get literals[0] and then matching post literals for each arg given\n\n  var result = typeof literals === \"string\" ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n} // Support typescript, which isn't as nice as Babel about default exports\n\n\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\nmodule.exports = gql;","map":{"version":3,"sources":["/home/goncalo/Desktop/FirstTimers/a-pop/node_modules/graphql-tag/src/index.js"],"names":["parser","require","parse","normalize","string","replace","trim","docCache","fragmentSourceMap","cacheKeyFromLoc","loc","source","body","substring","start","end","resetCaches","printFragmentWarnings","processFragments","ast","astFragmentMap","definitions","i","length","fragmentDefinition","kind","fragmentName","name","value","sourceKey","hasOwnProperty","console","warn","push","disableFragmentWarnings","stripLoc","doc","removeLocAtThisLevel","docType","Object","prototype","toString","call","map","d","Error","startToken","endToken","keys","key","valueType","experimentalFragmentVariables","parseDocument","cacheKey","parsed","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","gql","args","Array","slice","arguments","literals","result","default","module","exports"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,yBAAD,CAApB;;AAEA,IAAIC,KAAK,GAAGF,MAAM,CAACE,KAAnB,C,CAEA;AACA;;AACA,SAASC,SAAT,CAAmBC,MAAnB,EAA2B;AACzB,SAAOA,MAAM,CAACC,OAAP,CAAe,SAAf,EAA0B,GAA1B,EAA+BC,IAA/B,EAAP;AACD,C,CAED;;;AACA,IAAIC,QAAQ,GAAG,EAAf,C,CAEA;;AACA,IAAIC,iBAAiB,GAAG,EAAxB;;AAEA,SAASC,eAAT,CAAyBC,GAAzB,EAA8B;AAC5B,SAAOP,SAAS,CAACO,GAAG,CAACC,MAAJ,CAAWC,IAAX,CAAgBC,SAAhB,CAA0BH,GAAG,CAACI,KAA9B,EAAqCJ,GAAG,CAACK,GAAzC,CAAD,CAAhB;AACD,C,CAED;;;AACA,SAASC,WAAT,GAAuB;AACrBT,EAAAA,QAAQ,GAAG,EAAX;AACAC,EAAAA,iBAAiB,GAAG,EAApB;AACD,C,CAED;AACA;AACA;;;AACA,IAAIS,qBAAqB,GAAG,IAA5B;;AACA,SAASC,gBAAT,CAA0BC,GAA1B,EAA+B;AAC7B,MAAIC,cAAc,GAAG,EAArB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACE,WAAJ,CAAgBE,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/C,QAAIE,kBAAkB,GAAGL,GAAG,CAACE,WAAJ,CAAgBC,CAAhB,CAAzB;;AAEA,QAAIE,kBAAkB,CAACC,IAAnB,KAA4B,oBAAhC,EAAsD;AACpD,UAAIC,YAAY,GAAGF,kBAAkB,CAACG,IAAnB,CAAwBC,KAA3C;AACA,UAAIC,SAAS,GAAGpB,eAAe,CAACe,kBAAkB,CAACd,GAApB,CAA/B,CAFoD,CAIpD;;AACA,UAAIF,iBAAiB,CAACsB,cAAlB,CAAiCJ,YAAjC,KAAkD,CAAClB,iBAAiB,CAACkB,YAAD,CAAjB,CAAgCG,SAAhC,CAAvD,EAAmG;AAEjG;AACA;AACA,YAAIZ,qBAAJ,EAA2B;AACzBc,UAAAA,OAAO,CAACC,IAAR,CAAa,iCAAiCN,YAAjC,GAAgD,oBAAhD,GACT,iGADS,GAET,8EAFJ;AAGD;;AAEDlB,QAAAA,iBAAiB,CAACkB,YAAD,CAAjB,CAAgCG,SAAhC,IAA6C,IAA7C;AAED,OAZD,MAYO,IAAI,CAACrB,iBAAiB,CAACsB,cAAlB,CAAiCJ,YAAjC,CAAL,EAAqD;AAC1DlB,QAAAA,iBAAiB,CAACkB,YAAD,CAAjB,GAAkC,EAAlC;AACAlB,QAAAA,iBAAiB,CAACkB,YAAD,CAAjB,CAAgCG,SAAhC,IAA6C,IAA7C;AACD;;AAED,UAAI,CAACT,cAAc,CAACS,SAAD,CAAnB,EAAgC;AAC9BT,QAAAA,cAAc,CAACS,SAAD,CAAd,GAA4B,IAA5B;AACAR,QAAAA,WAAW,CAACY,IAAZ,CAAiBT,kBAAjB;AACD;AACF,KA1BD,MA0BO;AACLH,MAAAA,WAAW,CAACY,IAAZ,CAAiBT,kBAAjB;AACD;AACF;;AAEDL,EAAAA,GAAG,CAACE,WAAJ,GAAkBA,WAAlB;AACA,SAAOF,GAAP;AACD;;AAED,SAASe,uBAAT,GAAmC;AACjCjB,EAAAA,qBAAqB,GAAG,KAAxB;AACD;;AAED,SAASkB,QAAT,CAAkBC,GAAlB,EAAuBC,oBAAvB,EAA6C;AAC3C,MAAIC,OAAO,GAAGC,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BN,GAA/B,CAAd;;AAEA,MAAIE,OAAO,KAAK,gBAAhB,EAAkC;AAChC,WAAOF,GAAG,CAACO,GAAJ,CAAQ,UAAUC,CAAV,EAAa;AAC1B,aAAOT,QAAQ,CAACS,CAAD,EAAIP,oBAAJ,CAAf;AACD,KAFM,CAAP;AAGD;;AAED,MAAIC,OAAO,KAAK,iBAAhB,EAAmC;AACjC,UAAM,IAAIO,KAAJ,CAAU,mBAAV,CAAN;AACD,GAX0C,CAa3C;AACA;;;AACA,MAAIR,oBAAoB,IAAID,GAAG,CAAC1B,GAAhC,EAAqC;AACnC,WAAO0B,GAAG,CAAC1B,GAAX;AACD,GAjB0C,CAmB3C;;;AACA,MAAI0B,GAAG,CAAC1B,GAAR,EAAa;AACX,WAAO0B,GAAG,CAAC1B,GAAJ,CAAQoC,UAAf;AACA,WAAOV,GAAG,CAAC1B,GAAJ,CAAQqC,QAAf;AACD;;AAED,MAAIC,IAAI,GAAGT,MAAM,CAACS,IAAP,CAAYZ,GAAZ,CAAX;AACA,MAAIa,GAAJ;AACA,MAAIrB,KAAJ;AACA,MAAIsB,SAAJ;;AAEA,OAAKD,GAAL,IAAYD,IAAZ,EAAkB;AAChB,QAAIA,IAAI,CAAClB,cAAL,CAAoBmB,GAApB,CAAJ,EAA8B;AAC5BrB,MAAAA,KAAK,GAAGQ,GAAG,CAACY,IAAI,CAACC,GAAD,CAAL,CAAX;AACAC,MAAAA,SAAS,GAAGX,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+Bd,KAA/B,CAAZ;;AAEA,UAAIsB,SAAS,KAAK,iBAAd,IAAmCA,SAAS,KAAK,gBAArD,EAAuE;AACrEd,QAAAA,GAAG,CAACY,IAAI,CAACC,GAAD,CAAL,CAAH,GAAiBd,QAAQ,CAACP,KAAD,EAAQ,IAAR,CAAzB;AACD;AACF;AACF;;AAED,SAAOQ,GAAP;AACD;;AAED,IAAIe,6BAA6B,GAAG,KAApC;;AACA,SAASC,aAAT,CAAuBhB,GAAvB,EAA4B;AAC1B,MAAIiB,QAAQ,GAAGlD,SAAS,CAACiC,GAAD,CAAxB;;AAEA,MAAI7B,QAAQ,CAAC8C,QAAD,CAAZ,EAAwB;AACtB,WAAO9C,QAAQ,CAAC8C,QAAD,CAAf;AACD;;AAED,MAAIC,MAAM,GAAGpD,KAAK,CAACkC,GAAD,EAAM;AAAEe,IAAAA,6BAA6B,EAAEA;AAAjC,GAAN,CAAlB;;AACA,MAAI,CAACG,MAAD,IAAWA,MAAM,CAAC7B,IAAP,KAAgB,UAA/B,EAA2C;AACzC,UAAM,IAAIoB,KAAJ,CAAU,+BAAV,CAAN;AACD,GAVyB,CAY1B;AACA;;;AACAS,EAAAA,MAAM,GAAGpC,gBAAgB,CAACoC,MAAD,CAAzB;AACAA,EAAAA,MAAM,GAAGnB,QAAQ,CAACmB,MAAD,EAAS,KAAT,CAAjB;AACA/C,EAAAA,QAAQ,CAAC8C,QAAD,CAAR,GAAqBC,MAArB;AAEA,SAAOA,MAAP;AACD;;AAED,SAASC,mCAAT,GAA+C;AAC7CJ,EAAAA,6BAA6B,GAAG,IAAhC;AACD;;AAED,SAASK,oCAAT,GAAgD;AAC9CL,EAAAA,6BAA6B,GAAG,KAAhC;AACD,C,CAED;;;AACA,SAASM,GAAT;AAAa;AAAiB;AAC5B,MAAIC,IAAI,GAAGC,KAAK,CAACnB,SAAN,CAAgBoB,KAAhB,CAAsBlB,IAAtB,CAA2BmB,SAA3B,CAAX;AAEA,MAAIC,QAAQ,GAAGJ,IAAI,CAAC,CAAD,CAAnB,CAH4B,CAK5B;;AACA,MAAIK,MAAM,GAAI,OAAOD,QAAP,KAAqB,QAAtB,GAAkCA,QAAlC,GAA6CA,QAAQ,CAAC,CAAD,CAAlE;;AAEA,OAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoC,IAAI,CAACnC,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,QAAIoC,IAAI,CAACpC,CAAD,CAAJ,IAAWoC,IAAI,CAACpC,CAAD,CAAJ,CAAQG,IAAnB,IAA2BiC,IAAI,CAACpC,CAAD,CAAJ,CAAQG,IAAR,KAAiB,UAAhD,EAA4D;AAC1DsC,MAAAA,MAAM,IAAIL,IAAI,CAACpC,CAAD,CAAJ,CAAQZ,GAAR,CAAYC,MAAZ,CAAmBC,IAA7B;AACD,KAFD,MAEO;AACLmD,MAAAA,MAAM,IAAIL,IAAI,CAACpC,CAAD,CAAd;AACD;;AAEDyC,IAAAA,MAAM,IAAID,QAAQ,CAACxC,CAAD,CAAlB;AACD;;AAED,SAAO8B,aAAa,CAACW,MAAD,CAApB;AACD,C,CAED;;;AACAN,GAAG,CAACO,OAAJ,GAAcP,GAAd;AACAA,GAAG,CAACzC,WAAJ,GAAkBA,WAAlB;AACAyC,GAAG,CAACvB,uBAAJ,GAA8BA,uBAA9B;AACAuB,GAAG,CAACF,mCAAJ,GAA0CA,mCAA1C;AACAE,GAAG,CAACD,oCAAJ,GAA2CA,oCAA3C;AAEAS,MAAM,CAACC,OAAP,GAAiBT,GAAjB","sourcesContent":["var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n"]},"metadata":{},"sourceType":"script"}